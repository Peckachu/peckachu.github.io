---
layout: post
#title:  "Welcome to Jekyll!"
title:  "Naughty ELFs, Part One"
date:   2024-12-19 10:33:27 -0600
categories: jekyll update
---

# Introduction

Greetings, ‘tis the season of elfs! And in the sprit of the holidays, this post will be discussing ELFs!! In particular, what to do when encountering naughty ELFs, why they *(some)* exist, and what security researchers can do about their trickery.
{: style="text-align: justify;"}

## ELFS?!

*Woot! Who doesn't like elfs? They tell the funniest jokes!!!* <br />
![Image](/assets/images/did-hear-about-elf-quit-because-he-hated-making-toys-hes-rebel-without-claus-icanhascheezeurgercom.jpeg) <br/> 
*No, no, not those kinds of elfs… wait… that’s not even ah... ..., nevermind. (\*sigh, is this what happens when ai teach the lessons\*)*

While some elfs are indeed a type of majestic creature, it is also an acronym known as the **Executable and Linkable Format (ELF)**. This file format is commonly used for executables and was chosen as the standard executable for many unix and linux systems. These ELFs run across all types of systems from desktops to gaming consoles to automotive and much more. Given their importance on many systems, it is necessary for security researchers to understand their roles and structure. So, let's peck away *(ha!)* at them to understand the basics. 
{: style="text-align: justify;"}

In general, ELFs come in three typical flavors:
{: style="text-align: justify;"}

1. **Executable Files:** Programs or binaries that run, for example the best text editor around (ie. vim)
2. **Object Files:** Intermediate files generated by compilers, linked together to create executables
3. **Shared Libraries:** Reusable code libraries, multiple programs can load to save memory (RAM) 
{: style="text-align: justify;"}

There is another flavor of ELFs that may be obvious to developers and elusive to blackbox researcher. This flavor can be defined as:
{: style="text-align: justify;"}

{:start="4"}
4. **Integration Files:** Embedded system development files for the purpose of flashing or debugging 

*Wait... doesn't this mean, as security researchers, getting this type of ELF should make our lives easier?* <br />
*Yes! Or, that is what I would like to say...* 

It turns out sometimes legitimate ELFs are compiled in such a way that they wreak havoc on the tools that parse and use the ELF information. While ELFs of all flavors can be quite naughty in this way all the examples, in this post, will be using the *integration* type of ELF that has been compiled with the TASKING Tricore (cctc) toolchain. 
{: style="text-align: justify;"}

**Note:** Since TASKING only offers a two week evaluation version and must be discontinued or purchased after that evaluation period none of the code or examples will be release. The examples are simple to recreated and a two week trail for TASKING can be requested from their main site.
{: style="text-align: justify;"}

To understand the ways disruptive ELFs can break tools, it is necessary to understand the information that many tools collect from the ELFs, which can be done by understanding the ELF structure.
{: style="text-align: justify;"}

## ELF Structure

Many, many other tutorials exist that cover ELFs in far better and greater detail than this post could achieve. So, this will be a shallow overview of the ELF structure. If you are look for some additional reading material on ELFs there is always: the [elf spec](https://refspecs.linuxfoundation.org/elf/elf.pdf), [man 5 elf](https://man7.org/linux/man-pages/man5/elf.5.html), and, of course, you can't go wrong with some good old-fashion [source code](https://github.com/bminor/binutils-gdb/blob/master/bfd/elf.c). 
{: style="text-align: justify;"}

ELFs typically (although not required) have five parts: header, program header table, section header table, sections, and segments. Using a compiled ELF file and the ***readelf*** utility each part can be examined for information.
{: style="text-align: justify;"}

1. **ELF Header:** Provides identification and location of other ELF information. The header tells the system what ELF it is dealing with, where to find the different sections, and other important metadata. It resides at the beginning of an ELF file and is the only part of an ELF to have a fixed position.<br /><br />
**`readelf -h`** dumps ELF header information
	```bash
	$ readelf -h helloworld.elf
	
	ELF Header:
	  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
	  Class:                             ELF32
	  Data:                              2 s complement, little endian
	  Version:                           1 (current)
	  OS/ABI:                            UNIX - System V
	  ABI Version:                       0
	  Type:                              EXEC (Executable file)
	  Machine:                           Siemens Tricore
	  Version:                           0x1
	  Entry point address:               0xa0000020
	  Start of program headers:          52 (bytes into file)
	  Start of section headers:          3283600 (bytes into file)
	  Flags:                             0x100000
	  Size of this header:               52 (bytes)
	  Size of program headers:           32 (bytes)
	  Number of program headers:         99
	  Size of section headers:           40 (bytes)
	  Number of section headers:         120
	  Section header string table index: 1
	```
The output shows ***helloworld.elf*** is compiled for a Tricore LE processor, it is marked an an executable ELF, and the starting address is 0xa0000020 for this binary. 
{: style="text-align: justify;"}

{:start="2"}
2. **Program Header Table:** Specifies the segments and permissions to load in memory. This section is crucial for executable and shared libraries. <br /><br />
**readelf -l** dumps the program headers
	```bash
	$ readelf -l helloworld.elf
	
	Elf file type is EXEC (Executable file)
	Entry point 0xa0000020
	There are 99 program headers, starting at offset 52

	Program Headers:
	  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
	  LOAD           0x0040e4 0x80000000 0x80000000 0x00004 0x00004 R E 0x8
	  LOAD           0x003fa4 0x80000004 0x80000004 0x0000a 0x0000a R E 0x2
	  [...]
	  LOAD           0x002394 0x800000cc 0x800000cc 0x00008 0x00008 R   0x4
	```
{: style="text-align: justify;"}

{:start="3"}
3. **Section Header Table:** Describes the different sections in the ELF, such as data, code, and debug information. Every section has an entry in this table, and each section has a name and an offset, telling the system where to find it and what it contains. <br /> <br />
**`readelf -S`** displays the sections
	```bash
	$readelf -S helloworld.elf
	There are 120 section headers, starting at offset 0x321a90:
	
	Section Headers:
	[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
	[ 0]                   NULL            00000000 000000 000000 00      0   0  0
	[ 1] .shstrtab         STRTAB          00000000 320971 00111c 00      0   0  0
	[ 2] .strtab           STRTAB          00000000 31d928 003049 00      0   0  0
	[ 3] .symtab           SYMTAB          00000000 1cd080 002140 10      2 309  0
	...
	[94] .text.libc.reset  PROGBITS        80001970 004372 000030 00 AXp  0   0  2
	...
	Key to Flags:                                                                                     
	 W (write), A (alloc), X (execute), M (merge), S (strings), I (info),          
	 L (link order), O (extra OS processing required), G (group), T (TLS),         
	 C (compressed), x (unknown), o (OS specific), E (exclude),                    
	 D (mbind), p (processor specific)
	``` 
{: style="text-align: justify;"}

{:start="4"}
4. **Sections:** Contains the actual contents. Some common sections:
- **.text:** Executable code
- **.data:** Initialized globals and static variables
- **.bss:** Uninitialized variables, zeroed at runtime
- **.symtab:** Symbol table, which lists symbols and their locations
- **.notes:** Stores additional metadata and system-specific information<br /><br />
**`readelf -s`** displays the symbol table
	```bash
  	Symbol table '.symtab' contains 532 entries:
  	 Num:    Value  Size Type    Bind   Vis      Ndx Name
  	   0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
  	   1: 00000000     0 FILE    LOCAL  DEFAULT  ABS .\helloworld.elf
  	   2: 00000000     0 FILE    LOCAL  DEFAULT  ABS cstart.src
  	   3: 800036d0     0 FUNC    LOCAL  DEFAULT    4 .L43
  	   4: 800036d0     0 FUNC    LOCAL  DEFAULT    4 .dokofun_8
  	   5: a0000040     0 FUNC    LOCAL  DEFAULT    5 .L32
  	 ...
  	 306: 00000000     0 SECTION LOCAL  DEFAULT  115 trapvec_tc1
  	 307: 00000000     0 SECTION LOCAL  DEFAULT  116 trapvec_tc2
	```
{: style="text-align: justify;"}

{:start="5"}
5. **Segments:** Chunks of data loaded into memory <br /><br />
**`readelf -l`** dumps the program headers and **segment mapping**:
	```bash
	 Section to Segment mapping:
	  Segment Sections...
	   00     .data._Exit.libc 
	   01     .text.helloworld_LED.blinkLED 
	   02     .text.helloworld_LED.blinkLED1 
	   03     .text.dokofun_1.libc_fpu
	   [...]
	```
{: style="text-align: justify;"}

## Security Tools

With a whirlwind understanding of ELFs, it becomes easier to see the information security tools my glean from ELFs. For example, the header gives the machine architecture and type of ELF, the entry address gives a good starting location to decompile and origin point for analysis, if the ELF has a ***.symtab*** all entries could give additional functions and useful function names. The program headers list memory locations and permissions. Every datapoint an ELF gives is another possible place for analysis and heuristics that can assist security researchers. 
{: style="text-align: justify;"}

Naughty ELFs *(sometimes just misunderstood ☹️)* break analysis, break heuristics, and their trickery often causing hours of troubleshooting. One example of this is an ELF giving TOO much information such that it breaks decompilation. ***helloworld.elf*** happens to be such an ELF giving an opportunity to investigate the matter.   
{: style="text-align: justify;"}


### Decompilation

Decompilation is the process of turning machine code into human-readable source code. It starts with translating binary into assembly and then applying various algorithms and heuristics to construct a type of high level pseudo code. There are a few different tools that offer decompilation: Ghidra (free), Binary Ninja (pay $\$), IDA pro (pay $\$\$\$\$), etc... Ghidra will be used for this example--mainly because Binary Ninja's Tricore support is a paid plugins.
{: style="text-align: justify;"}

### Ghidra

Ghidra's analysis begins by loading the ***helloworld.elf*** into Ghidra. It's loader then parses the ELF file format and can take care of some of the heavy lifting. For example, it parses the ELF header to get the processor type and automatically specify the correct proccessor language. Errors are only encounter when the machine type is *none* or Ghidra can not find the specific language type. In this example, the latter issue is encountered.
{: style="text-align: justify;"}

Since the exact type of processor can not be found Ghidra wants it to be specified. From the previous **`readelf -h`** output, the architecture was identified as a Tricore LE, additional research (or insider knowledge) into the hardware would yield a processor in the AURIX 2G Family, specifically the TC375. This processor type is not an option, so the fallback option is to pick the closest type and hope that it is good enough (spoiler alert–-it is good enough!).
{: style="text-align: justify;"}

![Image](/assets/images/24_12_19_ghidra1_language.png)
{: style="width: 75%; height: auto;"}

Here we specify the processor language as Tricore TC29x and with some additional clicking, Ghidra loads the ELF file and begins analysis. 
{: style="text-align: justify;"}

The ***helloworld.elf*** was constructed to be a simple binary with a hardcoded backdoor password for authentication (think [*fauxware*](https://github.com/angr/angr-doc/blob/master/examples/fauxware/fauxware.c)). Looking at Ghidra's decompilation for **main()** shows there is an issue as the main function is barely populated:
{: style="text-align: justify;"}

![Image](/assets/images/24_12_19_ghidra2_main.png)

Looking closer, not only is the decompilation not populated, the disassembly is hard to read and cluttered with ***.L***'s. *So, what's happening here?* 
{: style="text-align: justify;"}

As part of the heavy lifting, Ghidra has parsed the ***.symtab*** in the ELF and provided readable labels. This is actually extremely helpful in most cases, the problem here is stemming from an overzealous ELF and a compiler that provided both useful debug symbols and not so useful symbols. These ***.L*** symbols are compiler-generated local symbols and their locations overlap with our main function causing the decompilation analysis to break early thinking each line is a new function. 
{: style="text-align: justify;"}

There are a few different ways we can address this issue, first, we can delete the symbols from the symbol table in Ghidra. Occasionally, this option is ***good enough*** and allows for analysis to continue. In Ghidra, open up the Symbol Table (ctrl+t), filter on ***.L***, sometimes ***.L\****, highlight all the matching symbols (ctrl+a) and delete.
{: style="text-align: justify;"}
![Image](/assets/images/24_12_19_ghidra3_symboltable.png)

It may take a moment for the deletion and reanalysis to complete. Once complete the results should show a more useful analysis in Ghidra.
{: style="text-align: justify;"}
![Image](/assets/images/24_12_19_ghidra4_main.png)

From the above picture, it looks like Ghidra was able to clean up the assembly code making it more continuous and easier to read. It did not, however, do much for decompliation. 
{: style="text-align: justify;"}

The next option that can be leveraged is to use a utility that parses the ELF file and strips local symbols. One such utility is aptly called ***strip*** and reading the manual for it will lead to two necessary flags:
{: style="text-align: justify;"}
> \-F bfdname\-\-target=bfdname <br />
Treat the original objfile as a file with the object code format bfdname, and rewrite it in the same format. See Target Selection, for more information. <br />
... <br />
\-X\-\-discard-locals <br />
Remove compiler-generated local symbols. (These usually start with ‘L’ or ‘.’.)

***helloworld.elf*** can now be stripped of its local symbols. There is one more problem though, the typical linux ***strip*** utility does not have support for the Tricore architecture and a ***tricore-strip*** utility must be located. This is easy enough but leads to the possibility of one more hurdle. Depending on the version of ***tricore-strip*** it may not support the TC 1.6.2 which the TC375 uses. The work around for that issues is the *-F* option in the below command:
{: style="text-align: justify;"}

```shell
# -F option is because this version of tricore-strip did not support the TC 1.6 architecture
tricore-strip.exe -F elf32-little -X -o helloworld_stripped.elf helloworld.elf
```
{: style="text-align: justify;"}

With the local symbols stripped from ***helloworld_stripped.elf***, this binary is loaded into Ghidra. The processor is again specified and analysis begins. This time Ghidra shows use some sweet, sweet, decomplation. 
{: style="text-align: justify;"}
![Image](/assets/images/24_12_19_ghidra5_main.png)

That's a wrap for now, stay tuned for future ELF adventures!
{: style="text-align: justify;"}

